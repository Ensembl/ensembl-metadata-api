/* 
 * This file defines what API calls we are going to handle
 * where we got our gRPC definition and what request and response
 * side or server side or both.
 * It's used to generate two files:
 * ensembl_metadata_pb2: which has all the different requests and responses
 * ensembl_metadata_pb2_grpc: which has the services that we want to implement 
 *   and the "stubs" that we will be using in the client side 
 */


syntax = "proto3";

package ensembl_metadata;

// IMPORTANT: the directory structure of the protos directory should mirror the structure of the src directory to avoid
// Python import errors.

// Metadata for the genomes in Ensembl.
service EnsemblMetadata {
  // Retrieve genome by its UUID.
  rpc GetGenomeByUUID(GenomeUUIDRequest) returns (Genome) {}

  // Retrieve genome UUID by providing production name and assembly id.
  rpc GetGenomeUUID(GenomeInfoRequest) returns (GenomeUUID) {}

  // Retrieve genomes by keyword search
  rpc GetGenomesByKeyword(GenomeByKeywordRequest) returns (stream Genome) {}

  // Retrieve all genomes for a give assembly accession ID
  rpc GetGenomesByAssemblyAccessionID(AssemblyAccessionIDRequest) returns (stream Genome) {}

  // Get species information for a genome UUID
  rpc GetSpeciesInformation(GenomeUUIDRequest) returns (Species) {}

  // Get assembly information
  rpc GetAssemblyInformation(AssemblyIDRequest) returns (AssemblyInfo) {}

  // Get subspecies information
  rpc GetSubSpeciesInformation(OrganismIDRequest) returns (SubSpecies) {}

  // Get karyotype information
  rpc GetKaryotypeInformation(GenomeUUIDRequest) returns (Karyotype) {}

  // Get top level statistics
  rpc GetTopLevelStatistics(OrganismIDRequest) returns (TopLevelStatistics) {}

  // Get top level statistics by UUID
  rpc GetTopLevelStatisticsByUUID(GenomeUUIDRequest) returns (TopLevelStatisticsByUUID) {}

  // Retrieve genome by Ensembl name and site, and optionally release.
  rpc GetGenomeByName(GenomeNameRequest) returns (Genome) {}

  // Retrieve release details.
  rpc GetRelease(ReleaseRequest) returns (stream Release) {}

  // Retrieve release details for a genome.
  rpc GetReleaseByUUID(GenomeUUIDRequest) returns (stream Release) {}

  // Retrieve sequence metadata for a genome's assembly.
  rpc GetGenomeSequence(GenomeSequenceRequest) returns (stream GenomeSequence) {}

  // Retrieve region information for a genome's assembly.
  rpc GetGenomeAssemblySequence(GenomeAssemblySequenceRequest) returns (stream GenomeAssemblySequence) {}

  // Retrieve region information for a genome's assembly with a given sequence region name.
  rpc GetGenomeAssemblySequenceRegion(GenomeAssemblySequenceRegionRequest) returns (GenomeAssemblySequenceRegion) {}

  // Retrieve a list of dataset_ids associated with a genome UUID.
  rpc GetDatasetsListByUUID(DatasetsRequest) returns (Datasets) {}
  
  // Retrieve dataset info by genome uuid and dataset_type
  rpc GetDatasetInformation(GenomeDatatypeRequest) returns (DatasetInfos) {}

  // Retrieve organisms group count
  rpc GetOrganismsGroupCount(OrganismsGroupRequest) returns (OrganismsGroupCount) {}
}

/*
A genome is a collection of datasets for an assembly,
which may or may not be in the current Ensembl release.
 */
message Genome {
  string genome_uuid = 1;
  Assembly assembly = 2;
  Taxon taxon = 3;
  string created = 4;
  Organism organism = 5;
  Release release = 6;
}

message Karyotype {
   string code = 1;
   string chromosomal = 2;
   string location = 3;
   string genome_uuid = 4;
}

message Species {
  string genome_uuid = 1;
  uint32 taxon_id = 2;
  string scientific_name = 3;
  string scientific_parlance_name = 4;
  string genbank_common_name = 5;
  repeated string synonym = 6;
}

message AssemblyInfo {
  string assembly_uuid = 1;
  string accession = 2;
  string level = 3;
  string name = 4;
  uint32 chromosomal = 5;
  // length will be a string, because some browser can't handle a full 64bit value as a number,
  // so the only way to ensure they can work for those clients is to handle them as strings
  // source: https://github.com/protocolbuffers/protobuf/issues/2679
  uint64 length = 6;
  string sequence_location = 7;
  string md5 = 8;
  string sha512t4u = 9;
}

message SubSpecies {
  string organism_uuid = 1;
  repeated string species_type = 2;
  repeated string species_name = 3;
}

message TopLevelStatistics {
  string organism_uuid = 1;
  message AttributeStatistics {
    string name = 2;
    string label = 3;
    string statistic_type = 4;
    string statistic_value = 5;
  }
  repeated AttributeStatistics statistics = 2;
}

message TopLevelStatisticsByUUID {
  string genome_uuid = 1;
  message AttributeStatistics {
    string name = 2;
    string label = 3;
    string statistic_type = 4;
    string statistic_value = 5;
  }
  repeated AttributeStatistics statistics = 2;
}

/*
An INSDC record of a genome assembly.
 */
message Assembly {
  string accession = 1;
  string name = 2;
  string ucsc_name = 3;
  string level = 4;
  string ensembl_name = 5;
  string tol_id = 6;
}

/*
Taxonomic information derived from the NCBI Taxonomy.
 */
message Taxon {
  uint32 taxonomy_id = 1;
  string scientific_name = 2;
  string strain = 3;
  repeated string common_name = 4;
}

/*
Release details for all Ensembl sites.
 */
message Release {
  double release_version = 1;
  string release_date = 2;
  string release_label = 3;
  bool is_current = 4;
  string site_name = 5;
  string site_label = 6;
  string site_uri = 7;
}

message Organism {
  string common_name = 1;
  string strain = 2;
  string scientific_name = 3;
  string ensembl_name = 4;
  string scientific_parlance_name = 5;
  string organism_uuid = 6;
}

/*
Wrapper for a list of DatasetInfo objects
*/
message DatasetInfos {
  string genome_uuid = 1;
  string dataset_type = 2;
  /*
  Details for datasets
  */
  message DatasetInfo {
    string dataset_uuid = 1;
    string dataset_name = 2;
    string name = 3;
    string type = 4;
    string dataset_version = 5;
    string dataset_label = 6;
    double version = 7;
    string value = 8;
  }
  repeated DatasetInfo dataset_infos = 3;
}

/*
Metadata about the sequences that comprise a genome's assembly.
 */
message GenomeSequence {
  string accession = 1;
  string name = 2;
  string sequence_location = 3;
  uint64 length = 4;
  bool chromosomal = 5;
}

/*
Metadata about the sequences that comprise a genome's assembly.
 */
message GenomeAssemblySequence {
  string name = 1;
  int32 rank = 2;
  string md5 = 3;
  uint64 length = 4;
  string sha512t4u = 5;
  bool chromosomal = 6;
}

/*
Metadata about the sequences that comprise a genome's assembly.
 */
message GenomeAssemblySequenceRegion {
  string name = 1;
  string md5 = 2;
  uint64 length = 3;
  string sha512t4u = 4;
  bool chromosomal = 5;
}

/*
Datasets list associated to the provided genome_uuid 
 */
message Datasets {
  string genome_uuid = 1;
  // https://stackoverflow.com/q/56401376/4488332
  // https://developers.google.com/protocol-buffers/docs/reference/python-generated#map-fields
  map<string, DatasetInfos> datasets = 2;
}

/*
Genome UUID
 */
message GenomeUUID {
  string genome_uuid = 1;
}

message OrganismsGroup {
  uint32 species_taxonomy_id = 1;
  string ensembl_name = 2;
  string common_name = 3;
  string scientific_name = 4;
  uint32 order = 5;
  uint32 count = 6;
}

message OrganismsGroupCount {
  repeated OrganismsGroup organisms_group_count = 1;
  double release_version = 2;
}

/*
The messages below are used to request data - required-ness is not enforced
by protocol buffers, but in practice some fields are mandatory in order to
receive a non-empty response, so this is indicated with a comment.
 */

/*
Genome UUID filter.
If release_version is not given, the current version is used.
 */
message GenomeUUIDRequest {
  string genome_uuid = 1; // Mandatory
  double release_version = 2; // Optional
}

/*
Genome keyword filter.
If release_version is not given, the current version is used.
 */
message GenomeByKeywordRequest {
  string keyword = 1; // Mandatory
  double release_version = 2; // Optional
}

/*
Genome name filter.
If release_version is not given, the current version is used.
 */
message GenomeNameRequest {
  string ensembl_name = 1;    // Mandatory
  string site_name = 2;       // Mandatory
  double release_version = 3; // Optional
}

/*
Assembly ID filter
 */
message AssemblyIDRequest {
  string assembly_uuid = 1; // Mandatory
}

/*
Assembly ID filter
 */
message AssemblyAccessionIDRequest {
  string assembly_accession = 1; // Mandatory
}

message OrganismIDRequest {
  string organism_uuid = 1;
  string group = 2;
}

/*
Release filter.
An empty message will return all releases, for all sites.
 */
message ReleaseRequest {
  repeated string site_name = 1;        // Optional
  repeated double release_version = 2;  // Optional
  bool current_only = 3;                // Optional
}

/*
Genome sequence filter.
 */
message GenomeSequenceRequest {
  string genome_uuid = 1;     // Mandatory
  bool chromosomal_only = 2;  // Optional
}

/*
Genome sequence filter.
 */
message GenomeAssemblySequenceRequest {
  string genome_uuid = 1;          // Mandatory
  bool chromosomal_only = 2;       // Optional
}

/*
Genome sequence filter.
TODO: Is there a way to DRY this since it's equivalent to GenomeAssemblySequenceRequest above plus sequence_region_name
 */
message GenomeAssemblySequenceRegionRequest {
  string genome_uuid = 1;          // Mandatory
  string sequence_region_name = 2;   // Mandatory
  bool chromosomal_only = 3;       // Optional
}

/*
Datasets filter.
 */
message DatasetsRequest {
  string genome_uuid = 1;     // Mandatory
  double release_version = 2; // Optional
}

/*
Genome datatype filter
 */
message GenomeDatatypeRequest {
  string genome_uuid = 1;     // Mandatory
  string dataset_type = 2;    // Mandatory
}

/*
Genome info filter used by Compara (EA-1090)
 */
message GenomeInfoRequest {
  string ensembl_name = 1;     // Mandatory
  string assembly_name = 2;    // Mandatory
  bool use_default = 3;        // Optional
}

/*
Organisms group count request
 */
message OrganismsGroupRequest {
  double release_version = 1; // Optional
}
