/* 
 * This file defines what API calls we are going to handle
 * where we got our gRPC definition and what request and response
 * side or server side or both.
 * It's used to generate two files:
 * ensembl_metadata_pb2: which has all the different requests and responses
 * ensembl_metadata_pb2_grpc: which has the services that we want to implement 
 *   and the "stubs" that we will be using in the client side 
 */


syntax = "proto3";

package ensembl_metadata;

// Metadata for the genomes in Ensembl.
service EnsemblMetadata {
  // Retrieve genome by its UUID.
  rpc GetGenomeByUUID(GenomeUUIDRequest) returns (Genome) {}

  // Get species information for a genome UUID
  rpc GetSpeciesInformation(GenomeUUIDRequest) returns (Species) {}

  // Get assembly information
  rpc GetAssemblyInformation(AssemblyIDRequest) returns (AssemblyInfo) {}

  // Get subspecies information
  rpc GetSubSpeciesInformation(OrganismIDRequest) returns (SubSpecies) {}

  // Get grouping information
  rpc GetGroupingInformation(OrganismIDRequest) returns (Grouping) {}

  // Get karyotype information
  rpc GetKaryotypeInformation(GenomeUUIDRequest) returns (Karyotype) {}

  // Get top level statistics
  rpc GetTopLevelStatistics(OrganismIDRequest) returns (TopLevelStatistics) {}

  // Retrieve genome by Ensembl name and site, and optionally release.
  rpc GetGenomeByName(GenomeNameRequest) returns (Genome) {}

  // Retrieve release details.
  rpc GetRelease(ReleaseRequest) returns (stream Release) {}

  // Retrieve release details for a genome.
  rpc GetReleaseByUUID(GenomeUUIDRequest) returns (stream Release) {}

  // Retrieve sequence metadata for a genome's assembly.
  rpc GetGenomeSequence(GenomeSequenceRequest) returns (stream GenomeSequence) {}

  // Retrieve a list of dataset_ids associated with a genome UUID.
  rpc GetDatasetsByUUID(GenomeUUIDRequest) returns (Datasets) {}
}

/*
A genome is a collection of datasets for an assembly,
which may or may not be in the current Ensembl release.
 */
message Genome {
  string genome_uuid = 1;
  string ensembl_name = 2;
  string url_name = 3;
  string display_name = 4;
  bool is_current = 5;
  Assembly assembly = 6;
  Taxon taxon = 7;
}

message Karyotype {
   string code = 1;
   string chromosomal = 2;
   string location = 3;
   string genome_uuid = 4;
}

message Species {
  string genome_uuid = 1;
  string common_name = 2;
  string ncbi_common_name = 4;
  uint32 taxon_id = 5;
  string scientific_name = 6;
  repeated string alternative_names = 7;
  string scientific_parlance_name = 8;
}

message AssemblyInfo {
  string assembly_id = 1;
  string accession = 2;
  string level = 3;
  string name = 4;
  uint32 chromosomal = 5;
  uint32 length = 6;
  string sequence_location = 7;
  string sequence_checksum = 8;
  string ga4gh_identifier = 9;
}

message SubSpecies {
  string organism_id = 1;
  repeated string species_type = 2;
  repeated string species_name = 3;
}

message Grouping {
  string organism_id = 1;
  repeated string species_type = 2;
  repeated string species_name = 3;
}

message TopLevelStatistics {
  string organism_id = 1;
  message AttributeStatistics {
    string name = 2;
    string label = 3;
    string statistic_type = 4;
    string statistic_value = 5;
  }
  repeated AttributeStatistics statistics = 2;
}

/*
An INSDC record of a genome assembly.
 */
message Assembly {
  string accession = 1;
  string name = 2;
  string ucsc_name = 3;
  string level = 4;
}

/*
Taxonomic information derived from the NCBI Taxonomy.
 */
message Taxon {
  uint32 taxonomy_id = 1;
  string scientific_name = 2;
  string strain = 3;
  repeated string common_name = 4;
}

/*
Release details for all Ensembl sites.
 */
message Release {
  uint32 release_version = 1;
  string release_date = 2;
  string release_label = 3;
  bool is_current = 4;
  string site_name = 5;
  string site_label = 6;
  string site_uri = 7;
}

/*
Metadata about the sequences that comprise a genome's assembly.
 */
message GenomeSequence {
  string accession = 1;
  string name = 2;
  string sequence_location = 3;
  uint32 length = 4;
  bool chromosomal = 5;
}

/*
The messages below are used to request data - required-ness is not enforced
by protocol buffers, but in practice some fields are mandatory in order to
receive a non-empty response, so this is indicated with a comment.
 */

/*
Genome UUID filter.
 */
message GenomeUUIDRequest {
  string genome_uuid = 1; // Mandatory
}

/*
Assembly ID filter
 */
message AssemblyIDRequest {
  string assembly_id = 1; // Mandatory
}

message OrganismIDRequest {
  string organism_id = 1;
}

/*
Genome name filter.
If release_version is not given, the current version is used.
 */
message GenomeNameRequest {
  string ensembl_name = 1;    // Mandatory
  string site_name = 2;       // Mandatory
  uint32 release_version = 3; // Optional
}

/*
Release filter.
An empty message will return all releases, for all sites.
 */
message ReleaseRequest {
  repeated string site_name = 1;        // Optional
  repeated uint32 release_version = 2;  // Optional
  bool current_only = 3;                // Optional
}

/*
Genome sequence filter.
 */
message GenomeSequenceRequest {
  string genome_uuid = 1;     // Mandatory
  bool chromosomal_only = 2;  // Optional
}

/*
Datasets list associated to the provided genome_uuid 
 */
 // Level 0
 message Datasets {
  string genome_uuid = 1;     // Mandatory
  // DatasetsInfo datasets = 2;
  // AssemblyDataset assembly_name = 2;
  map<string, DatasetsObject> datasets = 2;
  // string data_set_type_field = 3;
  // string data_set_type = 3;
}

// Level 1
message DatasetsObject{
  // AssemblyDataset datasets_obj = 1;
  // https://stackoverflow.com/q/56401376/4488332
  // https://developers.google.com/protocol-buffers/docs/reference/python-generated#map-fields
  repeated DatasetsInfo assembly_dataset = 1;
  // repeated DatasetsInfo align_xrefs_dataset = 2;
}

// Level 2
message DatasetsInfo {
  string dataset_uuid = 1;
  string dataset_name = 2;
  string dataset_version = 3;
  string dataset_label = 4;
  int32 version = 5;
}
